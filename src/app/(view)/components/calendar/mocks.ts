import type { TEventColor  , IEvent } from "@/types";


const COLORS: TEventColor[] = ["blue", "green", "red", "yellow", "purple", "orange", "gray"];

const EVENTS = [
  "111",
  "222"
];

// This was generated by AI -- minus the part where I added my wedding as an "easter egg" :)
const mockGenerator = (numberOfEvents: number): IEvent[] => {
  const result: IEvent[] = [
    {
      id: 1204,
      start_date: new Date("2025-09-20T00:00:00-03:00").toISOString(),
      end_date: new Date("2025-09-20T23:59:00-03:00").toISOString(),
      title: "My wedding :)",
      color: "red",
      description: "Can't wait to see the most beautiful woman in that dress!",
    },
  ];

  let currentId = 1;

  // Date range: 30 days before and after now
  const now = new Date();
  const startRange = new Date(now);
  startRange.setDate(now.getDate() - 30);
  const endRange = new Date(now);
  endRange.setDate(now.getDate() + 30);

  // Create an event happening now
  const currentEvent = {
    id: currentId++,
    start_date: new Date(now.getTime() - 30 * 60000).toISOString(),
    end_date: new Date(now.getTime() + 30 * 60000).toISOString(),
    title: EVENTS[Math.floor(Math.random() * EVENTS.length)],
    color: COLORS[Math.floor(Math.random() * COLORS.length)],
    description: "描述",
  };

  // Only add the current event if it's not on September 20th
  if (now.getMonth() !== 8 || now.getDate() !== 20) {
    // Month is 0-indexed (8 = September)
    result.push(currentEvent);
  }

  // Generate the remaining events
  let i = 0;
  let attempts = 0;
  const maxAttempts = numberOfEvents * 3; // Prevent infinite loop with a reasonable max attempts

  while (i < numberOfEvents - 1 && attempts < maxAttempts) {
    attempts++;

    // Determine if this is a multi-day event (10% chance)
    const isMultiDay = Math.random() < 0.1;

    const start_date = new Date(startRange.getTime() + Math.random() * (endRange.getTime() - startRange.getTime()));

    // Skip if the date is September 20th
    if (start_date.getMonth() === 8 && start_date.getDate() === 20) {
      continue;
    }

    // Set time between 8 AM and 8 PM
    start_date.setHours(8 + Math.floor(Math.random() * 8), Math.floor(Math.random() * 4) * 15, 0, 0);

    const end_date = new Date(start_date);

    if (isMultiDay) {
      // Multi-day event: Add 1-4 days
      const additionalDays = Math.floor(Math.random() * 4) + 1;
      end_date.setDate(start_date.getDate() + additionalDays);

      // Ensure multi-day events don't cross September 20th
      const endMonth = end_date.getMonth();
      const endDay = end_date.getDate();
      const startMonth = start_date.getMonth();
      const startDay = start_date.getDate();

      // Check if event spans across September 20th
      if (
        (startMonth === 8 && startDay < 20 && (endMonth > 8 || (endMonth === 8 && endDay >= 20))) ||
        (endMonth === 8 && endDay >= 20 && (startMonth < 8 || (startMonth === 8 && startDay < 20)))
      ) {
        continue;
      }

      end_date.setHours(8 + Math.floor(Math.random() * 12), Math.floor(Math.random() * 4) * 15, 0, 0);
    } else {
      const durationMinutes = (Math.floor(Math.random() * 11) + 2) * 15; // 30 to 180 minutes, multiple of 15
      end_date.setTime(end_date.getTime() + durationMinutes * 60 * 1000);
    }

    result.push({
      id: currentId++,
      start_date: start_date.toISOString(),
      end_date: end_date.toISOString(),
      title: EVENTS[Math.floor(Math.random() * EVENTS.length)],
      color: COLORS[Math.floor(Math.random() * COLORS.length)],
      description: "描述",
    });

    i++;
  }

  return result;
};

export const CALENDAR_ITENS_MOCK: IEvent[] = mockGenerator(80);
